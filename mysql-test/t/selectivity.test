--source include/have_stat_tables.inc

select @@global.use_stat_tables;
select @@session.use_stat_tables;

set @save_use_stat_tables=@@use_stat_tables;

set use_stat_tables='preferably';

set @save_optimizer_use_condition_selectivity=@@optimizer_use_condition_selectivity;
set @save_histogram_size=@@histogram_size;
set @save_histogram_type=@@histogram_type;

# check that statistics on nulls is used

set optimizer_use_condition_selectivity=3;

create table t1 (a int);
insert into t1 values
  (9), (3), (2), (NULL), (NULL), (2), (NULL), (1), (5), (NULL);

analyze table t1;

select * from mysql.column_stats;

flush table t1;

explain extended 
select * from t1 where a is null;

explain extended 
select * from t1 where a is not null;

drop table t1;

set optimizer_use_condition_selectivity=@save_optimizer_use_condition_selectivity;

--disable_warnings
DROP DATABASE IF EXISTS dbt3_s001;
--enable_warnings

CREATE DATABASE dbt3_s001;

use dbt3_s001;

--disable_query_log
--disable_result_log
--disable_warnings
--source include/dbt3_s001.inc

ANALYZE TABLE
customer, lineitem, nation, orders, part, partsupp, region, supplier;
FLUSH TABLE
customer, lineitem, nation, orders, part, partsupp, region, supplier;
--enable_warnings
--enable_result_log
--enable_query_log


--echo === Q15 ===

create view revenue0 (supplier_no, total_revenue) as
  select l_suppkey, sum(l_extendedprice * (1 - l_discount))
  from lineitem
  where
    l_shipdate >= '1995-08-01'
    and l_shipdate < date_add('1995-08-01', interval 90 day)
  group by l_suppkey;

let $Q15=
select s_suppkey, s_name, s_address, s_phone, total_revenue
from supplier, revenue0
where s_suppkey = supplier_no
  and total_revenue = (select max(total_revenue) from revenue0)
order by s_suppkey;

set @save_optimizer_switch=@@optimizer_switch;
set optimizer_switch='index_condition_pushdown=off';

set optimizer_use_condition_selectivity=1;
eval EXPLAIN EXTENDED $Q15;
eval $Q15;

set optimizer_use_condition_selectivity=3;
eval EXPLAIN EXTENDED $Q15;
eval $Q15;

set optimizer_switch=@save_optimizer_switch;

drop view revenue0;


--echo === Q16 ===

let $Q16=
select p_brand, p_type, p_size, count(distinct ps_suppkey) as supplier_cnt
from partsupp, part
where p_partkey = ps_partkey
  and p_brand <> 'Brand#11'
  and p_type not like 'SMALL POLISHED%'
  and p_size in (49, 37, 27, 5, 40, 6, 22, 8)
  and ps_suppkey not in (select s_suppkey from supplier
                           where s_comment like '%Customer%Complaints%')
group by p_brand, p_type, p_size
order by supplier_cnt desc, p_brand, p_type, p_size;

set optimizer_use_condition_selectivity=1;
eval EXPLAIN EXTENDED $Q16;
eval $Q16;

set optimizer_use_condition_selectivity=3;
eval EXPLAIN EXTENDED $Q16;
eval $Q16;

set optimizer_use_condition_selectivity=4;
eval EXPLAIN EXTENDED $Q16;
eval $Q16;


--echo === Q18 ===

let $Q18=
select 
  c_name, c_custkey, o_orderkey, o_orderdate, o_totalprice, sum(l_quantity)
from customer, orders, lineitem
where
  o_orderkey in (select l_orderkey from lineitem
                 group by l_orderkey having sum(l_quantity) > 250)
  and c_custkey = o_custkey
  and o_orderkey = l_orderkey
group by c_name, c_custkey, o_orderkey, o_orderdate, o_totalprice
order by o_totalprice desc, o_orderdate;

set optimizer_use_condition_selectivity=1;
eval EXPLAIN EXTENDED $Q18;
eval $Q18;

set optimizer_use_condition_selectivity=3;
eval EXPLAIN EXTENDED $Q18;
eval $Q18;


--echo === Q22 ===

let $Q22=
select cntrycode, count(*) as numcust, sum(c_acctbal) as totacctbal
from  (
    select substr(c_phone, 1, 2) as cntrycode, c_acctbal
    from customer
    where
      substr(c_phone, 1, 2) in ('10', '20', '14', '19', '11', '28', '25')
      and c_acctbal > (select avg(c_acctbal) from customer
                        where c_acctbal > 0.00
                          and substr(c_phone, 1, 2) in
                              ('10', '20', '14', '19', '11', '28', '25'))
      and not exists (select * from orders where o_custkey = c_custkey)
  ) as vip
group by cntrycode
order by cntrycode;

set optimizer_use_condition_selectivity=1;
eval EXPLAIN EXTENDED $Q22;
eval $Q22;

set optimizer_use_condition_selectivity=3;
eval EXPLAIN EXTENDED $Q22;
eval $Q22;


--echo === Q20 ===

let $Q20=
select sql_calc_found_rows
       s_name, s_address
from supplier, nation
where s_suppkey in (select ps_suppkey from partsupp
                    where ps_partkey in (select p_partkey from part
                                         where p_name like 'g%')
                          and ps_availqty >
                              (select 0.5 * sum(l_quantity)
                               from lineitem
                               where l_partkey = ps_partkey
                                     and l_suppkey = ps_suppkey
                                     and l_shipdate >= date('1993-01-01')
                                     and l_shipdate < date('1993-01-01') +
                                         interval '1' year ))
and s_nationkey = n_nationkey
and n_name = 'UNITED STATES'
order by s_name
limit 10;

set optimizer_use_condition_selectivity=1;
eval EXPLAIN EXTENDED $Q20;
eval $Q20;

SELECT ((SELECT COUNT(*) FROM part WHERE p_name LIKE 'g%') /
        (SELECT COUNT(*) FROM part)) AS sel;

set optimizer_use_condition_selectivity=3;
eval EXPLAIN EXTENDED $Q20;
eval $Q20;

set histogram_size=127;

ANALYZE TABLE part PERSISTENT FOR COLUMNS(p_name) INDEXES();

flush table part;

set optimizer_use_condition_selectivity=4;
eval EXPLAIN EXTENDED $Q20;
eval $Q20; 

set histogram_type='DOUBLE_PREC_HB';
set histogram_size=254;

ANALYZE TABLE part PERSISTENT FOR COLUMNS(p_name) INDEXES();

flush table part;

eval EXPLAIN EXTENDED $Q20;
eval $Q20; 

set histogram_type='SINGLE_PREC_HB';
set histogram_size=24;

ANALYZE TABLE nation PERSISTENT FOR COLUMNS(n_name) INDEXES();

flush table nation;

eval EXPLAIN EXTENDED $Q20;
eval $Q20; 


DROP DATABASE dbt3_s001;

set histogram_type=@save_histogram_type;
set histogram_size=@save_histogram_size;
set optimizer_use_condition_selectivity=@save_optimizer_use_condition_selectivity;

use test;

--echo #
--echo # Bug mdev-4348: using view with use_condition_selectivity > 1 
--echo #

set @tmp_use_stat_tables=@@use_stat_tables; 
set use_stat_tables='never';
set optimizer_use_condition_selectivity=3;

CREATE TABLE t1 (a int, b int);
INSERT t1 VALUES (7,1), (0,7);
CREATE ALGORITHM=MERGE VIEW v1 AS SELECT * FROM t1;

CREATE TABLE t2 (c int, d int, index idx(d));
INSERT INTO t2 VALUES 
  (0,4), (8,6), (1,3), (8,5), (9,3), (2,2), (6,2),
  (1,9), (6,3), (2,8), (4,1), (0,7), (4,8), (4,5);

EXPLAIN EXTENDED
SELECT * FROM v1 INNER JOIN t2 ON ( a = c AND b = d );

SELECT * FROM v1 INNER JOIN t2 ON ( a = c AND b = d );

DROP VIEW v1;
DROP TABLE t1,t2;

set optimizer_use_condition_selectivity=@save_optimizer_use_condition_selectivity;
set use_stat_tables=@tmp_use_stat_tables; 

--echo #
--echo # Bug mdev-4349: impossible range for non-indexed column 
--echo #

set optimizer_use_condition_selectivity=3;

create table t1 (a int);
insert into t1 values
  (3), (7), (2), (5), (7), (1), (2), (2);

set optimizer_use_condition_selectivity=1;
explain extended
select * from t1 where a < 1 and a > 7;
select * from t1 where a < 1 and a > 7;

set optimizer_use_condition_selectivity=3;
explain extended
select * from t1 where a < 1 and a > 7;
select * from t1 where a < 1 and a > 7;

drop table t1;

create table t1 (a int);
insert into t1 values (1);

create table t2 (b int);
insert into t2 values (2),(3);

explain extended 
select * from t1 where a in ( select b from t2 ) AND ( a > 3 );
select * from t1 where a in ( select b from t2 ) AND ( a > 3 );

drop table t1,t2;

set optimizer_use_condition_selectivity=@save_optimizer_use_condition_selectivity;

--echo #
--echo # Bug mdev-4350: erroneous negative selectivity 
--echo #

create table t1 (a int);
insert into t1 values (1), (1);
insert into t1 select * from t1; 
insert into t1 select * from t1; 
insert into t1 select * from t1; 
insert into t1 select * from t1; 
insert into t1 select * from t1; 
insert into t1 select * from t1; 
insert into t1 select * from t1; 
insert into t1 select * from t1; 
insert into t1 select * from t1; 
insert into t1 values (0);
select count(*) from t1;

set use_stat_tables='preferably';
set histogram_size=127;
set histogram_type='SINGLE_PREC_HB';
analyze table t1;
flush table t1;

set optimizer_use_condition_selectivity=4;
explain extended select * from t1 where a=0;

drop table t1;

set histogram_size=@save_histogram_size;
set histogram_type=@save_histogram_type;
set optimizer_use_condition_selectivity=@save_optimizer_use_condition_selectivity;

--echo #
--echo # Bug mdev-4367: 2-way join with an empty table 
--echo #                when optimizer_use_condition_selectivity=3
--echo #

set optimizer_use_condition_selectivity=3;

CREATE TABLE t1 (a varchar(1)) ENGINE=MyISAM;
INSERT INTO t1 VALUES ('j'),('k');

CREATE TABLE t2 (b varchar(1)) ENGINE=MyISAM;
INSERT INTO t2 VALUES ('x'),('y');

CREATE TABLE t3 (c varchar(1), KEY(c)) ENGINE=MyISAM;

SELECT * FROM t1 STRAIGHT_JOIN (t2 JOIN t3 ON c = b AND b > 'z');

DROP TABLE t1,t2,t3;

set optimizer_use_condition_selectivity=@save_optimizer_use_condition_selectivity;

--echo #
--echo # Bug mdev-4366: impossible condition on an indexed column discovered after
--echo #                substitution of constant tables
--echo #                with optimizer_use_condition_selectivity=3
--echo #

CREATE TABLE t1 (pk int PRIMARY KEY, a int);
INSERT INTO t1 VALUES 
  (1,4), (2,6), (3,3), (4,5);

CREATE TABLE t2 (b int);
INSERT INTO t2 VALUES (1), (7);

set optimizer_use_condition_selectivity=1;
EXPLAIN EXTENDED
SELECT 1 FROM t1, t2 WHERE pk = 6 AND a = 2 AND b = 10;
SELECT 1 FROM t1, t2 WHERE pk = 6 AND a = 2 AND b = 10;

set optimizer_use_condition_selectivity=3;
EXPLAIN EXTENDED
SELECT 1 FROM t1, t2 WHERE pk = 6 AND a = 2 AND b = 10;
SELECT 1 FROM t1, t2 WHERE pk = 6 AND a = 2 AND b = 10;

DROP TABLE t1,t2;

set optimizer_use_condition_selectivity=@save_optimizer_use_condition_selectivity;


set use_stat_tables=@save_use_stat_tables;
