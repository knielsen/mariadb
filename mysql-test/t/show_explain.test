#
# Tests for SHOW EXPLAIN FOR functionality
#
--source include/have_debug.inc

--disable_warnings
drop table if exists t0, t1;
--enable_warnings

# 
# Testcases in this file do not work with embedded server. The reason for this
# is that we use the following commands for synchronization:
#
#    set @show_explain_probe_select_id=1;
#    set debug='d,show_explain_probe_1';
#    send select count(*) from t1 where a < 100000;
#
# When ran with mysqltest_embedded, this translates into: 
#
#    Thread1> DBUG_PUSH("d,show_explain_probe_1");
#    Thread1> create another thread for doing "send ... reap"
#    Thread2> mysql_parse("select count(*) from t1 where a < 100000");
#
# That is, "select count(*) ..." is ran in a thread for which DBUG_PUSH(...)
# has not been called. As a result, show_explain_probe_1 does not fire, and
# "select count(*) ..." does not wait till its SHOW EXPLAIN command, and the
# test fails.
#
-- source include/not_embedded.inc


create table t0 (a int);
insert into t0 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t1 (a int);
insert into t1 select A.a + 10*B.a + 100*C.a from t0 A, t0 B, t0 C;
alter table t1 add b int, add c int, add filler char(32);
update t1 set b=a, c=a, filler='fooo';
alter table t1 add key(a), add key(b);

# 
# Try killing a non-existent thread
# 
--error ER_NO_SUCH_THREAD
show explain for 2*1000*1000*1000;

--error ER_NOT_SUPPORTED_YET
show explain for (select max(a) from t0);

# 
# Setup two threads and their ids
#
let $thr1=`select connection_id()`;
connect (con1, localhost, root,,);
connection con1;
let $thr2=`select connection_id()`;
connection default;

# SHOW EXPLAIN FOR <idle thread>
--error ER_ERROR_WHEN_EXECUTING_COMMAND
evalp show explain for $thr2;

# SHOW EXPLAIN FOR <ourselves>
--error ER_ERROR_WHEN_EXECUTING_COMMAND
evalp show explain for $thr1;

let $wait_condition= select State='show_explain_trap' from information_schema.processlist where id=$thr2;

#
# Test SHOW EXPLAIN for simple queries
#
connection con1;
set @show_explain_probe_select_id=1;
set debug='d,show_explain_probe_1';
send select count(*) from t1 where a < 100000;

connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
connection con1;
reap;


send select max(c) from t1 where a < 10;
connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
connection con1;
reap;


--echo # We can catch EXPLAIN, too.
set @show_expl_tmp= @@optimizer_switch;
set optimizer_switch='index_condition_pushdown=on,mrr=on,mrr_sort_keys=on';
send explain select max(c) from t1 where a < 10;
connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
connection con1;
reap;
set optimizer_switch= @show_expl_tmp;


--echo # UNION, first branch 
set @show_explain_probe_select_id=1;
set debug='d,show_explain_probe_1';
send explain select a from t0 A union select a+1 from t0 B;
connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
connection con1;
reap;

--echo # UNION, second branch
set @show_explain_probe_select_id=1;
set debug='d,show_explain_probe_1';
send explain select a from t0 A union select a+1 from t0 B;
connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
connection con1;
reap;

# Let's try with a subquery


## TODO: Test this: multiple SHOW EXPLAIN calls in course of running of one select
## 
## TODO: Test this: have several SHOW EXPLAIN requests be queued up for a
##       thread and served together.

drop table t0,t1;
