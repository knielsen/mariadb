#
# Tests for SHOW EXPLAIN FOR functionality
#
--source include/have_debug.inc

--disable_warnings
drop table if exists t0, t1, t2;
drop view if exists v1;
--enable_warnings

# 
# Testcases in this file do not work with embedded server. The reason for this
# is that we use the following commands for synchronization:
#
#    set @show_explain_probe_select_id=1;
#    set debug='d,show_explain_probe_1';
#    send select count(*) from t1 where a < 100000;
#
# When ran with mysqltest_embedded, this translates into: 
#
#    Thread1> DBUG_PUSH("d,show_explain_probe_1");
#    Thread1> create another thread for doing "send ... reap"
#    Thread2> mysql_parse("select count(*) from t1 where a < 100000");
#
# That is, "select count(*) ..." is ran in a thread for which DBUG_PUSH(...)
# has not been called. As a result, show_explain_probe_1 does not fire, and
# "select count(*) ..." does not wait till its SHOW EXPLAIN command, and the
# test fails.
#
-- source include/not_embedded.inc


create table t0 (a int);
insert into t0 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t1 (a int);
insert into t1 select A.a + 10*B.a + 100*C.a from t0 A, t0 B, t0 C;
alter table t1 add b int, add c int, add filler char(32);
update t1 set b=a, c=a, filler='fooo';
alter table t1 add key(a), add key(b);

# 
# Try killing a non-existent thread
# 
--error ER_NO_SUCH_THREAD
show explain for 2*1000*1000*1000;

--error ER_NOT_SUPPORTED_YET
show explain for (select max(a) from t0);

# 
# Setup two threads and their ids
#
let $thr1=`select connection_id()`;
connect (con1, localhost, root,,);
connection con1;
let $thr2=`select connection_id()`;
connection default;

# SHOW EXPLAIN FOR <idle thread>
--error ER_ERROR_WHEN_EXECUTING_COMMAND
evalp show explain for $thr2;

# SHOW EXPLAIN FOR <ourselves>
--error ER_ERROR_WHEN_EXECUTING_COMMAND
evalp show explain for $thr1;

let $wait_condition= select State='show_explain_trap' from information_schema.processlist where id=$thr2;

#
# Test SHOW EXPLAIN for simple queries
#
connection con1;
set @show_explain_probe_select_id=1;
set debug='d,show_explain_probe_1';
send select count(*) from t1 where a < 100000;

connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
connection con1;
reap;


send select max(c) from t1 where a < 10;
connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
connection con1;
reap;


--echo # We can catch EXPLAIN, too.
set @show_expl_tmp= @@optimizer_switch;
set optimizer_switch='index_condition_pushdown=on,mrr=on,mrr_sort_keys=on';
send explain select max(c) from t1 where a < 10;
connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
connection con1;
reap;
set optimizer_switch= @show_expl_tmp;


--echo # UNION, first branch 
set @show_explain_probe_select_id=1;
set debug='d,show_explain_probe_1';
send explain select a from t0 A union select a+1 from t0 B;
connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
connection con1;
reap;


--echo # UNION, second branch
set @show_explain_probe_select_id=1;
set debug='d,show_explain_probe_1';
send explain select a from t0 A union select a+1 from t0 B;
connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
connection con1;
reap;


--echo # Uncorrelated  subquery, select
set @show_explain_probe_select_id=1;
set debug='d,show_explain_probe_1';
send select a, (select max(a) from t0 B) from t0 A where a<1;
connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
connection con1;
reap;


--echo # Uncorrelated  subquery, explain
set @show_explain_probe_select_id=1;
set debug='d,show_explain_probe_1';
send explain select a, (select max(a) from t0 B) from t0 A where a<1;
connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
connection con1;
reap;

--echo # correlated  subquery, select
set @show_explain_probe_select_id=1;
set debug='d,show_explain_probe_1';
send select a, (select max(a) from t0 b where b.a+a.a<10) from t0 a where a<1;
connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
connection con1;
reap;

--echo # correlated  subquery, explain
set @show_explain_probe_select_id=1;
set debug='d,show_explain_probe_1';
send select a, (select max(a) from t0 b where b.a+a.a<10) from t0 a where a<1;
connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
connection con1;
reap;

--echo # correlated  subquery, select, while inside the subquery
set @show_explain_probe_select_id=2; # <---
set debug='d,show_explain_probe_1';
send select a, (select max(a) from t0 b where b.a+a.a<10) from t0 a where a<1;
connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
connection con1;
reap;

--echo # correlated  subquery, explain, while inside the subquery
set @show_explain_probe_select_id=2;
set debug='d,show_explain_probe_1';
send select a, (select max(a) from t0 b where b.a+a.a<10) from t0 a where a<1;
connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
connection con1;
reap;


# TODO: explain in the parent subuqery when the un-correlated child has been
# run (and have done irreversible cleanups)
#  ^^ Is this at all possible after 5.3? 
#     Maybe, for 5.3 try this: 
#       - run before/after the parent has invoked child's optimization
#       - run after materialization 

--echo # Try to do SHOW EXPLAIN for a query that runs a  SET command:
--echo #   I've found experimentally that select_id==2 here...
--echo # 
set @show_explain_probe_select_id=2;
set debug='d,show_explain_probe_1';
send set @foo= (select max(a) from t0 where sin(a) >0);
connection default;
--source include/wait_condition.inc
--error ER_ERROR_WHEN_EXECUTING_COMMAND
evalp show explain for $thr2;
connection con1;
reap;

--echo #
--echo # Attempt SHOW EXPLAIN for an UPDATE
--echo #
create table t2 as select a as a, a as dummy from t0 limit 2;
set @show_explain_probe_select_id=2;
set debug='d,show_explain_probe_1';
send update t2 set dummy=0 where (select max(a) from t0 where t2.a + t0.a <3) >3 ;
connection default;
--source include/wait_condition.inc
--error ER_ERROR_WHEN_EXECUTING_COMMAND
evalp show explain for $thr2;
--error ER_ERROR_WHEN_EXECUTING_COMMAND
evalp show explain for $thr2;
connection con1;
reap;
drop table t2;

--echo #
--echo # Attempt SHOW EXPLAIN for a DELETE
--echo # 
create table t2 as select a as a, a as dummy from t0 limit 2;
set @show_explain_probe_select_id=2;
set debug='d,show_explain_probe_1';
send delete from t2 where (select max(a) from t0 where t2.a + t0.a <3) >3 ;
connection default;
--source include/wait_condition.inc
--error ER_ERROR_WHEN_EXECUTING_COMMAND
evalp show explain for $thr2;
--error ER_ERROR_WHEN_EXECUTING_COMMAND
evalp show explain for $thr2;
connection con1;
reap;
drop table t2;


--echo #
--echo # Multiple SHOW EXPLAIN calls for one select 
--echo # 
create table t2 as select a as a, a as dummy from t0 limit 3;
set @show_explain_probe_select_id=2;
set debug='d,show_explain_probe_1';
send select t2.a, ((select max(a) from t0 where t2.a + t0.a <3) >3) as SUBQ from t2;
connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
evalp show explain for $thr2;
evalp show explain for $thr2;
connection con1;
reap;
drop table t2;

--echo #
--echo # SHOW EXPLAIN for SELECT ... ORDER BY with "Using filesort"
--echo #
explain select * from t0 order by a;

set debug='d,show_explain_probe_1';
set @show_explain_probe_select_id=1;
send select * from t0 order by a; 
connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
connection con1;
reap;

--echo #
--echo # SHOW EXPLAIN for SELECT ... with "Using temporary"
--echo #
connection default;
explain select distinct a from t0;
connection con1;

set debug='d,show_explain_probe_1';
set @show_explain_probe_select_id=1;
send select distinct a from t0; 
connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
connection con1;
reap;

--echo #
--echo # SHOW EXPLAIN for SELECT ... with "Using temporary; Using filesort"
--echo #
connection default;
explain select distinct a from t0;
connection con1;

set debug='d,show_explain_probe_1';
set @show_explain_probe_select_id=1;
send select distinct a from t0; 
connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
connection con1;
reap;
set debug='';

--echo #
--echo # MDEV-238: SHOW EXPLAIN: Server crashes in JOIN::print_explain with FROM subquery and GROUP BY
--echo #
CREATE TABLE t2 ( a INT ); 
INSERT INTO t2 VALUES (1),(2),(1),(4),(2);
explain SELECT alias.a FROM t2, ( SELECT * FROM t2 ) AS alias GROUP BY alias.a;

set debug='d,show_explain_in_find_all_keys';
send SELECT alias.a FROM t2, ( SELECT * FROM t2 ) AS alias GROUP BY alias.a;

connection default;
--source include/wait_condition.inc
--echo # NOTE: current code will not show "Using join buffer":
evalp show explain for $thr2;
connection con1;
reap;
set debug='';
DROP TABLE t2;


--echo #
--echo # MDEV-239: Assertion `field_types == 0 ... ' failed in Protocol_text::store(double, uint32, String*) with 
--echo #          SHOW EXPLAIN over EXPLAIN EXTENDED
--echo #


CREATE TABLE t2 (a INT); 
INSERT INTO t2 VALUES (1),(2),(1),(4),(2);

EXPLAIN EXTENDED SELECT alias.a FROM t2, ( SELECT * FROM t2 ) AS alias GROUP BY alias.a ;

set @show_explain_probe_select_id=1;
set debug='d,show_explain_probe_join_exec_end';
send EXPLAIN EXTENDED SELECT alias.a FROM t2, ( SELECT * FROM t2 ) AS alias GROUP BY alias.a ;

connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
connection con1;
reap;
set debug='';
DROP TABLE t2;


--echo #
--echo # MDEV-240: SHOW EXPLAIN: Assertion `this->optimized == 2' failed in 
--echo # JOIN::print_explain on query with a JOIN, TEMPTABLE view,
--echo #          
CREATE TABLE t3 (a INT); 
CREATE ALGORITHM=TEMPTABLE VIEW v1 AS SELECT * FROM t3;
INSERT INTO t3 VALUES (8);
CREATE TABLE t2 (b INT);
INSERT INTO t2 VALUES (4),(5),(6),(7),(8),(9);
explain SELECT * FROM v1, t2;

set @show_explain_probe_select_id=2;
set debug='d,show_explain_probe_join_exec_end';
send SELECT * FROM v1, t2;

connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
connection con1;
reap;
set debug='';
DROP VIEW v1;
DROP TABLE t2, t3;

--echo #
--echo # MDEV-267: SHOW EXPLAIN: Server crashes in JOIN::print_explain on most of queries
--echo #
set @show_explain_probe_select_id=1;
set debug='d,show_explain_probe_join_exec_end';
send select sleep(1);
connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
connection con1;
reap;
set debug='';


--echo #
--echo # Same as above, but try another reason for JOIN to be degenerate
--echo #
set @show_explain_probe_select_id=1;
set debug='d,show_explain_probe_join_exec_end';
send select * from t0 where 1>10;
connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
connection con1;
reap;
set debug='';

--echo #
--echo # Same as above, but try another reason for JOIN to be degenerate (2)
--echo #
create table t3(a int primary key);
insert into t3 select a from t0;
set @show_explain_probe_select_id=1;
set debug='d,show_explain_probe_join_exec_end';
send select * from t0,t3 where t3.a=112233;
connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
connection con1;
reap;
set debug='';
drop table t3;

--echo #
--echo # MDEV-270: SHOW EXPLAIN: server crashes in JOIN::print_explain on a query with 
--echo #           select tables optimized away
--echo #

CREATE TABLE t2 (pk INT PRIMARY KEY, a INT ) ENGINE=MyISAM; 
INSERT INTO t2 VALUES 
  (1,4),(2,62),(3,7),(4,1),(5,0),(6,7),(7,7),(8,1),(9,7),(10,1),
  (11,5),(12,2),(13,0),(14,1),(15,8),(16,1),(17,1),(18,9),(19,1),(20,5) ;

explain SELECT * FROM t2 WHERE a = 
       (SELECT MAX(a) FROM t2 
        WHERE pk= (SELECT MAX(pk) FROM t2 WHERE pk = 3)
       );

set @show_explain_probe_select_id=2;
set debug='d,show_explain_probe_do_select';
send SELECT * FROM t2 WHERE a = 
       (SELECT MAX(a) FROM t2 
        WHERE pk= (SELECT MAX(pk) FROM t2 WHERE pk = 3)
       );
connection default;
--source include/wait_condition.inc
evalp show explain for $thr2;
connection con1;
reap;
set debug='';
drop table t2;






## TODO: Test this: have several SHOW EXPLAIN requests be queued up for a
##       thread and served together.

drop table t0,t1;
