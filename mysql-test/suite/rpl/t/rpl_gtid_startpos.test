--source include/have_innodb.inc
--let $rpl_topology=1->2
--source include/rpl_init.inc

--echo *** Test connecting with empty GTID state to start from very beginning of binlog ***
--connection server_2
--source include/stop_slave.inc
RESET MASTER;
RESET SLAVE;

--connection server_1
RESET MASTER;
# Create an empty binlog file, to check that empty binlog state is handled correctly.
FLUSH LOGS;
CREATE TABLE t1 (a INT PRIMARY KEY) ENGINE=InnoDB;
--save_master_pos

--connection server_2
--replace_result $MASTER_MYPORT MASTER_PORT
eval CHANGE MASTER TO master_host = '127.0.0.1', master_port = $MASTER_MYPORT,
     MASTER_GTID_POS="";
--source include/start_slave.inc
--sync_with_master
SELECT * FROM t1;

--connection server_1
INSERT INTO t1 VALUES (1);
--save_master_pos

--connection server_2
--sync_with_master
SELECT * FROM t1;
--source include/stop_slave.inc

--echo *** Test that master gives error when slave asks for empty gtid pos and binlog files have been purged. ***
--connection server_1
FLUSH LOGS;
INSERT INTO t1 VALUES (2);
--save_master_pos
--let $purge_binlogs_to=master-bin.000003
--source include/wait_for_purge.inc
--source include/show_binary_logs.inc

--connection server_2
--replace_result $MASTER_MYPORT MASTER_PORT
eval CHANGE MASTER TO master_host = '127.0.0.1', master_port = $MASTER_MYPORT,
     MASTER_GTID_POS="";
START SLAVE;
--let $slave_io_errno= 1236
--source include/wait_for_slave_io_error.inc
--source include/stop_slave.inc

--replace_result $MASTER_MYPORT MASTER_PORT
eval CHANGE MASTER TO master_host = '127.0.0.1', master_port = $MASTER_MYPORT,
     MASTER_LOG_FILE="master-bin.000003", MASTER_LOG_POS=4;
--source include/start_slave.inc
--sync_with_master
SELECT * FROM t1 ORDER BY a;
SET sql_log_bin=0;
call mtr.add_suppression('Could not find GTID state requested by slave in any binlog files');
SET sql_log_bin=1;

--echo *** Test that we give error when explict MASTER_GTID_POS=xxx that conflicts with what is in our binary log ***
--source include/stop_slave.inc

--connection server_1
INSERT INTO t1 VALUES(3);

--connection server_2
--replace_result $MASTER_MYPORT MASTER_PORT
eval CHANGE MASTER TO master_host = '127.0.0.1', master_port = $MASTER_MYPORT,
     MASTER_GTID_POS='0-1-3';
--source include/start_slave.inc
--let $wait_condition= SELECT COUNT(*) = 3 FROM t1
--source include/wait_condition.inc
SELECT * FROM t1 ORDER by a;
--source include/stop_slave.inc

--connection server_1
INSERT INTO t1 VALUES (4);

--connection server_2
# Now add some local transactions that conflict with the GTID position
# being set for MASTER_GTID_POS.
INSERT INTO t1 VALUES (10);
DELETE FROM t1 WHERE a=10;
--replace_result $MASTER_MYPORT MASTER_PORT
--error ER_MASTER_GTID_POS_CONFLICTS_WITH_BINLOG
eval CHANGE MASTER TO master_host = '127.0.0.1', master_port = $MASTER_MYPORT,
     MASTER_GTID_POS='0-1-4';

# Try again after RESET MASTER to remove the conflicting binlog.
RESET MASTER;
--replace_result $MASTER_MYPORT MASTER_PORT
eval CHANGE MASTER TO master_host = '127.0.0.1', master_port = $MASTER_MYPORT,
     MASTER_GTID_POS='0-1-4';
START SLAVE;
--let $wait_condition= SELECT COUNT(*) = 4 FROM t1
--source include/wait_condition.inc
SELECT * FROM t1 ORDER by a;

--connection server_1
DROP TABLE t1;
--save_master_pos

--connection server_2
--sync_with_master


--echo *** MDEV-4275: I/O thread restart duplicates events in relay log ***

--connection server_2
--source include/stop_slave.inc
RESET SLAVE ALL;
RESET MASTER;

--connection server_1
RESET MASTER;

--connection server_2
--replace_result $MASTER_MYPORT MASTER_PORT
eval CHANGE MASTER TO master_host='127.0.0.1', master_port=$MASTER_MYPORT, master_user='root', master_gtid_pos='';
--source include/start_slave.inc

--connection server_1
CREATE TABLE t1 (a INT PRIMARY KEY);
INSERT INTO t1 VALUES (1);
--save_master_pos

--connection server_2
--sync_with_master
SELECT * FROM t1;

--source include/stop_slave_io.inc
START SLAVE IO_THREAD;
--source include/wait_for_slave_io_to_start.inc

--connection server_1
INSERT INTO t1 VALUES (2);
--save_master_pos

--connection server_2
--sync_with_master

SELECT * FROM t1 ORDER BY a;


--echo *** MDEV-4329: MASTER_GTID_POS='' is not checked for conflicts with binlog ***

# Test starting the slave completely from scratch, deleting all tables and
# replicating from the start of the master's binlog. This requires RESET
# MASTER is run on the slave to avoid old junk in the binlog. The bug was
# that the code did not catch the error of missing RESET MASTER when an
# empty MASTER_GTID_POS='' was specified.

--connection server_2
--source include/stop_slave.inc
DROP TABLE t1;
RESET SLAVE;
--error ER_MASTER_GTID_POS_MISSING_DOMAIN
eval CHANGE MASTER TO master_gtid_pos='';
RESET MASTER;
eval CHANGE MASTER TO master_gtid_pos='';

--source include/start_slave.inc
--sync_with_master
SELECT * FROM t1 ORDER BY a;


# Same thing, but this time using SQL_LOG_BIN=0 to avoid polliting the
# slave binlog.

--connection server_2
--source include/stop_slave.inc
SET SQL_LOG_BIN=0;
DROP TABLE t1;
SET SQL_LOG_BIN=1;
RESET SLAVE;
eval CHANGE MASTER TO master_gtid_pos='';

--source include/start_slave.inc
--sync_with_master
SELECT * FROM t1 ORDER BY a;

--echo *** Test that RESET SLAVE clears the Using_Gtid flag. ***
--source include/stop_slave.inc
RESET SLAVE;
--let $status_items= Using_Gtid
--source include/show_slave_status.inc

# Starting the slave now reverts to old-style position which defaults to
# the first non-purged binlog file on the master.
# This should give error due to table already existing.
START SLAVE;
--let $slave_sql_errno= 1050
--source include/wait_for_slave_sql_error.inc

# Going back to using GTID should fix things.
STOP SLAVE IO_THREAD;
CHANGE MASTER TO MASTER_GTID_POS=AUTO;
--source include/start_slave.inc

--connection server_1
INSERT INTO t1 VALUES(3);

--connection server_2
--let $wait_condition= SELECT COUNT(*) = 3 FROM t1
--source include/wait_condition.inc
SELECT * FROM t1 ORDER BY a;
SET SQL_LOG_BIN=0;
call mtr.add_suppression("Slave: Table 't1' already exists Error_code: 1050");
SET SQL_LOG_BIN=1;


--echo *** Test reconnecting slave with GTID after purge logs on master. ***

--connection server_1
FLUSH LOGS;
INSERT INTO t1 VALUES (4);

--connection server_2
--let $wait_condition= SELECT COUNT(*) = 4 FROM t1
--source include/wait_condition.inc
--source include/stop_slave.inc

--connection server_1
FLUSH LOGS;
FLUSH LOGS;
--let $purge_binlogs_to=master-bin.000004
--source include/wait_for_purge.inc
--source include/show_binary_logs.inc
INSERT INTO t1 VALUES (5);

--connection server_2
--replace_result $MASTER_MYPORT MASTER_PORT
eval CHANGE MASTER TO master_host = '127.0.0.1', master_port = $MASTER_MYPORT;
--source include/start_slave.inc
--let $wait_condition= SELECT COUNT(*) = 5 FROM t1
--source include/wait_condition.inc
SELECT * FROM t1 ORDER BY a;


# Clean up.
--connection server_1
DROP TABLE t1;


--source include/rpl_end.inc
