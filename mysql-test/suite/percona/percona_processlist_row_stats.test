# Testing of INFORMATION_SCHEMA.PROCESSLIST fields ROWS_SENT, ROWS_EXAMINED, ROWS_READ
--source include/have_debug_sync.inc

--disable_warnings
DROP TABLE IF EXISTS t1;
DROP TABLE IF EXISTS t2;
--enable_warnings

CREATE TABLE t2 (a INT);
INSERT INTO t2 VALUES(10);
INSERT INTO t2 VALUES(10);
INSERT INTO t2 VALUES(20);
INSERT INTO t2 VALUES(10);
INSERT INTO t2 VALUES(20);

connect (conn1, localhost, root, ,);
connect (conn2, localhost, root, ,);

--connection conn1
echo Issuing operation that should not return any rows and stopping the thread #1;
SET DEBUG_SYNC= 'locked_table_name SIGNAL thread1_ready WAIT_FOR threads_dumped';
send CREATE TABLE t1 (a INT);

--connection default
SET DEBUG_SYNC= 'now WAIT_FOR thread1_ready';
--echo Thread #1 stopped

--connection conn2
echo Issuing row-returning query and stopping the thread #2 at the end of query;
SET DEBUG_SYNC= 'execute_command_after_close_tables SIGNAL thread2_ready WAIT_FOR threads_dumped';
send SELECT a FROM t2 WHERE a > 15;

--connection default
SET DEBUG_SYNC= 'now WAIT_FOR thread2_ready';
--echo Thread #2 stopped
--echo Look at thread states

--replace_column 1 ### 3 ### 6 ### 7 ###
SHOW PROCESSLIST;
# The running threads are different between SHOW above and SELECT below.  Thus select info too to 
# show the difference.  Results are in the same order as in SHOW.
--replace_column 1 ###
SELECT id, info, rows_sent, rows_examined, rows_read FROM information_schema.processlist 
ORDER BY id;

echo Let threads #1 and #2 finish their job;
SET DEBUG_SYNC= 'now SIGNAL threads_dumped';

--connection conn1
reap;

--connection conn2
reap;
echo Issuing row-returning query and stopping the thread #2 in the middle of query;
SET DEBUG_SYNC= 'sent_row SIGNAL thread2_ready WAIT_FOR threads_dumped';
send SELECT a FROM t2 WHERE a > 15;

--connection default
SET DEBUG_SYNC= 'now WAIT_FOR thread2_ready';
echo Thread #2 stopped, look at its state;

--replace_column 1 ### 3 ### 6 ### 7 ###
SHOW PROCESSLIST;
--replace_column 1 ###
SELECT id,rows_sent,rows_examined,rows_read FROM INFORMATION_SCHEMA.PROCESSLIST ORDER BY Id;
SET DEBUG_SYNC= 'now SIGNAL threads_dumped';
echo Let thread #2 finish its job;

--connection conn2
reap;
echo Issuing an UPDATE and stopping thread #2;
SET DEBUG_SYNC= 'execute_command_after_close_tables SIGNAL thread2_ready WAIT_FOR threads_dumped';
send UPDATE t2 SET a = 15 WHERE a = 10;

--connection default
SET DEBUG_SYNC= 'now WAIT_FOR thread2_ready';
echo Thread #2 stopped, look at its state;

--replace_column 1 ### 3 ### 6 ### 7 ###
SHOW PROCESSLIST;
--replace_column 1 ###
SELECT id,rows_sent,rows_examined,rows_read FROM INFORMATION_SCHEMA.PROCESSLIST ORDER BY Id;
SET DEBUG_SYNC= 'now SIGNAL threads_dumped';
echo Let thread #2 finish its job;

--connection conn2
reap;

--connection default
disconnect conn1;
disconnect conn2;
DROP TABLES t1, t2;
